2025-04-13 22:12
Tags: #Interview #nodejs 

- [libuv](#libuv)
- [Knowledge of Asynchronous programming model](#Knowledge%20of%20Asynchronous%20programming%20model)
- [Authorization](#Authorization)
- [ACL (Access Control List)](#ACL%20(Access%20Control%20List))
- [Для загрузки и хранения файлов/изображений](#Для%20загрузки%20и%20хранения%20файлов/изображений)
- [Logging](#Logging)
- [Monitoring](#Monitoring)
- [Performance](#Performance)
- [Deploy](#Deploy)
- [Server configuration](#Server%20configuration)
- [NoSQL and SQL databases](#NoSQL%20and%20SQL%20databases)
- [Ansible](#Ansible)
- [Как вернуть файл клиенту](#Как%20вернуть%20файл%20клиенту)

---

### libuv

Библиотека, написанная на C, которая предоставляет асинхронный ввод/вывод (I/O). Она играет ключевую роль в реализации асинхронного поведения Node.js.

---

### Knowledge of Asynchronous programming model

Node.js использует **Event Loop** , который позволяет выполнять неблокирующие операции. Основные концепции:

- **Callback functions** — функции, которые вызываются после завершения асинхронной операции.
- **Promises** — объекты, представляющие результат завершенной операции.
- **Async/Await** — синтаксический сахар над Promises для более удобного написания асинхронного кода.

---

### Authorization

- JWT
- Session
- OAuth 2.0

---

### ACL (Access Control List)

Механизм контроля доступа, который определяет, какие пользователи или системы имеют права на выполнение определенных действий. Например:

- Пользователь A может читать и писать.
- Пользователь B может только читать.


---

### Для загрузки и хранения файлов/изображений

1. **Получить файл от клиента** через HTTP-запрос (`multipart/form-data`).
2. **Разобрать входящий поток данных** , чтобы извлечь файл.
3. **Сохранить файл** на сервере с использованием модуля `fs`.

---

### Logging

Это процесс записи событий, происходящих в приложении, в файлы или другие системы. Это помогает отслеживать работу приложения, выявлять ошибки и анализировать производительность.

console.log, winston, pino

---

### Monitoring

Процесс наблюдения за состоянием приложения в реальном времени. Это помогает выявлять проблемы до того, как они повлияют на пользователей, и обеспечивать стабильность системы.

1. **Производительность сервера** - загрузка CPU, использование памяти, дисковое пространство.
2. **Производительность приложения** - время ответа на запросы, частота ошибок, количество запросов.
3. **Использование базы данных** - время выполнения запросов, количество подключений.
4. **Ошибки и исключения** - количество и типы ошибок.
5. **События бизнес-логики** - например, количество регистраций пользователей, успешных платежей и т.д.

---

### Performance

- Используйте нативные модули (например, `bcrypt` вместо JavaScript-реализации).
- Минимизируйте блокирующие операции.
- Используйте кластеризацию (`cluster` module) для использования нескольких ядер процессора.

---

### Deploy

- **PM2** — менеджер процессов для запуска Node.js приложений.
- **Docker** — контейнеризация приложений.
- **AWS/Azure** — облачные платформы для размещения приложений.

---

### Server configuration

- Не запускать Node.js под root. Использовать непривилегированного пользователя
- Использование **PM2**
- Использование **Nginx**/**Apache**
- Обслуживание статических файлов через Node.js

---

### NoSQL and SQL databases

 **SQL (PostgreSQL, MySQL):** Для структурированных данных и сложных запросов.
 
 **NoSQL (MongoDB, Redis):** Для неструктурированных данных и высокой масштабируемости.

---

### Ansible

Инструмент автоматизации, который используется для управления конфигурацией серверов, развёртывания приложений, настройки инфраструктуры и выполнения задач по обслуживанию.

---

### Как вернуть файл клиенту

**Используя стримы:**
Для больших файлов лучше использовать стримы. Они позволяют передавать данные по частям, что снижает нагрузку на память и улучшает производительность.
```js
const fs = require('fs');
const path = require('path');

app.get('/file', (req, res) => {
  const filePath = path.join(__dirname, 'files', 'example.pdf');
  const fileStream = fs.createReadStream(filePath);
  res.setHeader('Content-Type', 'application/pdf');
  fileStream.pipe(res);
});
```

**Не используя стримы:**
Если файл небольшой, можно прочитать его целиком в память. Это простой способ, но он может быть неэффективным для больших файлов, так как весь файл загружается в память.
```js
app.get('/file', (req, res) => {
  res.download(path.join(__dirname, 'files', 'example.pdf'));
});
```

**Как статику:**
Express предоставляет встроенный метод `express.static`, который позволяет легко отдавать статические файлы. Этот подход удобен, когда нужно отдавать множество файлов из одной директории.
```js
app.use('/static', express.static('files'));
```

---
### Links
[[Interview]]