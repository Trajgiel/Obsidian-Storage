2026-02-17 19:39
Tags: #Interview #golang #panic

- [Почему error — это интерфейс, а не специальный тип данных?](#Почему%20error%20—%20это%20интерфейс,%20а%20не%20специальный%20тип%20данных?)
- [В чем разница между errors.New() и fmt.Errorf()?](#В%20чем%20разница%20между%20errors.New()%20и%20fmt.Errorf()?)
- [Опишите механизм работы errors.Is() и errors.As(). Когда что применять?](#Опишите%20механизм%20работы%20errors.Is()%20и%20errors.As().%20Когда%20что%20применять?)
- [Как реализовать кастомный тип ошибки, который поддерживает Unwrap()?](#Как%20реализовать%20кастомный%20тип%20ошибки,%20который%20поддерживает%20Unwrap()?)
- [Стоит ли возвращать указатель на ошибку (*MyError) или само значение? Почему?](#Стоит%20ли%20возвращать%20указатель%20на%20ошибку%20(*MyError)%20или%20само%20значение?%20Почему?)
- [В какой момент стоит логировать ошибку, а в какой — просто возвращать её выше по стеку?](#В%20какой%20момент%20стоит%20логировать%20ошибку,%20а%20в%20какой%20—%20просто%20возвращать%20её%20выше%20по%20стеку?)
- [Почему проверка if err != nil считается преимуществом языка, а не недостатком?](#Почему%20проверка%20if%20err%20!=%20nil%20считается%20преимуществом%20языка,%20а%20не%20недостатком?)
- [Что происходит с горутиной при возникновении panic?](#Что%20происходит%20с%20горутиной%20при%20возникновении%20panic?)
- [В каких случаях panic оправдан в продакшен-коде?](#В%20каких%20случаях%20panic%20оправдан%20в%20продакшен-коде?)
- [Как работает recover()? Где именно его нужно вызывать, чтобы он сработал?](#Как%20работает%20recover()?%20Где%20именно%20его%20нужно%20вызывать,%20чтобы%20он%20сработал?)
- [Может ли recover() поймать панику в другой горутине?](#Может%20ли%20recover()%20поймать%20панику%20в%20другой%20горутине?)
- [Что такое defer? Опишите порядок выполнения нескольких defer](#Что%20такое%20defer?%20Опишите%20порядок%20выполнения%20нескольких%20defer)
- [Когда вычисляются аргументы функции, переданной в defer?](#Когда%20вычисляются%20аргументы%20функции,%20переданной%20в%20defer?)
- [Как defer влияет на именованные возвращаемые значения (named return values)?](#Как%20defer%20влияет%20на%20именованные%20возвращаемые%20значения%20(named%20return%20values)?)
- [Какова стоимость вызова defer?](#Какова%20стоимость%20вызова%20defer?)
- [Что будет, если вызвать panic внутри блока defer?](#Что%20будет,%20если%20вызвать%20panic%20внутри%20блока%20defer?)
- [Что произойдет, если recover() вызван, но паники не было?](#Что%20произойдет,%20если%20recover()%20вызван,%20но%20паники%20не%20было?)

---

### Почему error — это интерфейс, а не специальный тип данных?

В Go `error` сделан интерфейсом с одним методом `Error() string`, чтобы обеспечить максимальную гибкость и явность в обработке ошибок.
```go
type error interface {
    Error() string
}
```

##### 1. **Гибкость**
Любой тип может реализовать интерфейс `error`, просто добавив метод `Error() string`. Это позволяет создавать кастомные типы ошибок с дополнительной информацией:
```go
type MyError struct {
    Code    int
    Message string
    Time    time.Time
}

func (e *MyError) Error() string {
    return fmt.Sprintf("[%d] %s at %v", e.Code, e.Message, e.Time)
}
```

##### 2. **Простота**

Интерфейс с одним методом — это минималистичный подход, характерный для Go. Он легко понимается и реализуется.

Go предпочитает композицию наследованию. Интерфейсы позволяют разным типам ошибок "быть ошибками" без необходимости наследования от базового класса.
##### 3. **Обёртывание ошибок (wrapping)**

Поскольку это интерфейс, легко создавать обёртки для ошибок, добавляя контекст:
```go
type wrappedError struct {
    err   error
    msg   string
}

func (w *wrappedError) Error() string {
    return w.msg + ": " + w.err.Error()
}
```

---

### В чем разница между errors.New() и fmt.Errorf()?

`errors.New()` и `fmt.Errorf()` — это два основных способа создания ошибок в Go, но они различаются по функциональности и производительности.

##### 1. **errors.New()** (из пакета `errors`)
```go
func New(text string) error
```
- Принимает только **строку** и создает ошибку с этим сообщением
- Простой и быстрый способ создать ошибку
- Не поддерживает форматирование
- Быстрее (~0.17 нс) и не выделяет лишнюю память.[](https://www.linkedin.com/pulse/optimize-your-go-code-use-errorsnew-instead-fmterrorf-engin-a%C3%A7%C4%B1kg%C3%B6z-j28hf)​
```go
err := errors.New("пользователь не найден")
err := errors.New("ошибка подключения к базе данных")
```

##### 2. **fmt.Errorf()** (из пакета `fmt`)
```go
func Errorf(format string, a ...any) error
```
- Поддерживает **форматирование строки** (как `fmt.Sprintf`)
- Позволяет вставлять переменные в сообщение об ошибке (контекст)
- С **Go 1.13+** поддерживает **обертывание ошибок** через `%w` (wrapping)
- Медленнее (~68 нс) из-за форматирования
```go
// С форматированием
err := fmt.Errorf("пользователь с ID %d не найден", userID)
err := fmt.Errorf("ошибка: %s, код: %d", message, code)

// С обертыванием ошибки (Go 1.13+)
originalErr := someFunction()
err := fmt.Errorf("не удалось обработать данные: %w", originalErr)
```

В современном Go чаще используется `fmt.Errorf()` из-за его гибкости!

---

### Опишите механизм работы errors.Is() и errors.As(). Когда что применять?
`errors.Is()` и `errors.As()` — это функции из пакета `errors`, которые работают с цепочками ошибок, созданными через `%w` в `fmt.Errorf` (ошибками, которые оборачивают другие ошибки).
Они проходят по дереву ошибок (через `Unwrap()`) и позволяют проверять совпадения без прямого `==` или `type assertion`.

##### 1. `errors.Is(err, target error)`
Рекурсивно проверяет, **является ли ошибка** (или любая в её цепочке) **конкретным значением**.
```go
   err := io.EOF
    
    if errors.Is(err, io.EOF) {
        fmt.Println("Достигнут конец файла")
    }
```
**Когда применять:** Когда нужно проверить **значение** ошибки.

##### 2. `errors.As(err interface{}, target interface{})`
Рекурсивно проверяет **тип ошибки** в цепочке и **извлекает** её в указатель для доступа к полям.
```go
var pathErr *PathError
    err := &PathError{Path: "/tmp/file.txt", Err: errors.New("permission denied")}
    
    if errors.As(err, &pathErr) {
        fmt.Printf("Ошибка пути: %s\n", pathErr.Path)
        // Теперь можно использовать поля и методы PathError
    }
```
**Когда применять:** Когда нужна **структурированная информация** из ошибки.

##### Резюме

- **`errors.Is()`** — для проверки: «Является ли ошибка (или какая-то в цепочке) этой конкретной ошибкой?»
- **`errors.As()`** — для извлечения: «Есть ли в цепочке ошибка такого типа, и если да — дай мне к ней доступ»

Обе функции работают с **цепочками ошибок**, поэтому их нужно использовать вместо прямого сравнения `err == io.EOF` или приведения типов, когда ошибки оборачиваются через `fmt.Errorf("%w", err)` или метод `Unwrap()`.

---

### Как реализовать кастомный тип ошибки, который поддерживает Unwrap()?

Чтобы реализовать кастомный тип ошибки в Go с поддержкой `Unwrap()`, нужно создать структуру, которая реализует интерфейс `error` (метод `Error()`) и дополнительно метод `Unwrap() error`. Это позволит использовать `errors.Is()`, `errors.As()` и `errors.Unwrap()` из пакета `errors` (Go 1.13+).

```go
import (
    "errors"
    "fmt"
)

type CustomError struct {
    msg string
    err error // вложенная ошибка
}

// Обязательный метод для интерфейса error
func (e *CustomError) Error() string {
    if e.err != nil {
        return fmt.Sprintf("%s: %v", e.msg, e.err)
    }
    return e.msg
}

// Метод для поддержки unwrap (Go 1.13+)
func (e *CustomError) Unwrap() error {
    return e.err
}

func someOperation() error {
    baseErr := errors.New("базовая ошибка")
    return &CustomError{
        msg: "кастомная обертка",
        err: baseErr,
    }
}

func main() {
    err := someOperation()
    fmt.Println(err) // "кастомная обертка: базовая ошибка"
    
    // Проверяем тип через цепочку ошибок
    var target *CustomError
    if errors.As(err, &target) {
        fmt.Println("Это CustomError:", target.msg)
    }
    
    // Проверяем конкретную ошибку в цепочке
    if errors.Is(err, errors.New("базовая ошибка")) {
        fmt.Println("Найдена базовая ошибка")
    }
    
    // Извлекаем вложенную ошибку
    unwrapped := errors.Unwrap(err)
    fmt.Println("Unwrapped:", unwrapped)
}
```

##### Альтернатива с fmt.Errorf (%w)

Если не нужен кастомный тип, используй стандартный способ:
```go
err := fmt.Errorf("кастомное сообщение: %w", errors.New("базовая ошибка"))
if errors.Is(err, errors.New("базовая ошибка")) {
    // сработает
}
```
Этот подход проще, но кастомный тип дает больше контроля (дополнительные поля, методы).

---

### Стоит ли возвращать указатель на ошибку (*MyError) или само значение? Почему?
В Go стандартная практика — возвращать **значение ошибки** (`error`), а не указатель на неё (`*MyError`). Это значение обычно либо `nil` (успех), либо конкретный объект, реализующий интерфейс `error`.

Стандартная библиотека Go всегда возвращает значения `error` — посмотрите на `errors.New()`, `fmt.Errorf()`, `io.EOF`. Указатели не используются, потому что:
- Интерфейс `error` содержит метод `Error() string`, который работает одинаково для значений и указателей.
- Значения ошибок **маленькие и копируются дёшево** (обычно это строка или небольшая структура).
- Нет необходимости в мутабельности — ошибки иммутабельны по дизайну.

Всегда возвращайте `error`, а не `*error`. Это идиоматичный код, который легко читать и поддерживать.

---

### В какой момент стоит логировать ошибку, а в какой — просто возвращать её выше по стеку?

В Go принято **возвращать ошибку вверх по стеку** в большинстве случаев, а **логировать только на границе системы** (handler, middleware, main), где ошибка преобразуется в ответ пользователю или завершение программы.

##### Когда **НЕ** стоит логировать ошибку (просто возвращаем):
1. **Внутри пакета / на уровне бизнес-логики**
    - Если вы находитесь в середине цепочки вызовов
    - Когда ошибка — это ожидаемый результат, который вызывающий код может обработать
    - Если вы не обладаете контекстом для принятия решения
2. **Когда вызывающий код может восстановиться**
    - Например, попробовать альтернативный путь, повторить запрос и т.д.

##### Когда **стоит** логировать ошибку:
1. **На границе слоёв / на верхнем уровне**
    - В `main()`, HTTP-хендлерах, фоновых воркерах
    - Когда ошибка достигает точки, где она больше не может быть обработана
2. **Когда ошибка не может быть восстановлена**
    - Критические ошибки, которые требуют внимания
3. **Когда вы добавляете контекст и "съедаете" ошибку**
    - Если вы не возвращаете ошибку выше, а обрабатываете её на месте

##### Золотое правило:
> **Логируйте ошибку там, где она впервые становится необрабатываемой (или там, где вы принимаете решение её "съесть").**

##### Полезная практика: обёртывание ошибок

Используйте `fmt.Errorf("...: %w", err)` для добавления контекста, но не логируйте на каждом уровне.
Таким образом, логирование происходит **один раз** — на верхнем уровне, а стек ошибки сохраняется через `errors.Is`, `errors.As`, или `%+v` с `pkg/errors`.

---

### Почему проверка if err != nil считается преимуществом языка, а не недостатком?
Проверка `if err != nil` в Go считается преимуществом, потому что она делает обработку ошибок **явной, предсказуемой и компилируемой**.

##### Явная сигнатура функций
Вместо скрытых исключений (как в Java/C++) каждая функция четко объявляет, что может вернуть ошибку.
```go
func readFile(path string) ([]byte, error)  // Ошибка в сигнатуре!
```
Компилятор заставит обработать `error` — забудешь проверку, код не соберется.

##### Типобезопасность и контроль потока
```go
f, err := os.Open("file.txt")
if err != nil {
    return err  // Ранний выход, логика дальше не выполняется
}
defer f.Close()  // Гарантированное закрытие
```
- Нет "магии" исключений — видишь все пути выполнения
- Легко добавить контекст: `fmt.Errorf("read %s: %w", path, err)`
- Можно вернуть несколько значений: `found bool, err error`

##### Обработка наверху (не внизу)
```go
func processUser(id int) error {
    user, err := db.GetUser(id)
    if err != nil { return err }
    
    orders, err := db.GetOrders(user.ID)
    if err != nil { return err }
    
    // main() или middleware решает, что делать с ошибкой
    return sendReport(user, orders)
}
```
В `main()` или HTTP handler'е:
```go
if err := processUser(123); err != nil {
    log.Printf("failed: %v", err)  // Логируем с контекстом
    http.Error(w, "bad request", 400)
    return
}
```


Это заставляет писать надежный код — сначала бесит, потом ценишь предсказуемость!

---

### Что происходит с горутиной при возникновении panic?

##### Последствия для горутины
- Go начинает **unwinding стека** (раскрутку стека вызовов) именно в этой горутине.
- Выполняются все **defer-функции** в обратном порядке (LIFO) до момента panic.
- Если в этих defer вызывается `recover()`, паника **поймана** — горутина продолжает работу.

##### Последствия для программы
- **Panic изолирован** — не распространяется на другие горутины и main.[](https://habr.com/ru/companies/otus/articles/900452/)​
- Если recover не вызван, после unwinding **вся программа крашится** с выводом stack trace **только проблемной горутины**.
- Остальные горутины **продолжают работать** до своего завершения или другой паники.

##### Безопасный запуск горутин
```go
func safeGo(fn func()) {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Panic пойман: %v\n%s", r, debug.Stack())
            }
        }()
        fn()
    }()
}
```
**Всегда** используй такую обёртку для production![](https://habr.com/ru/companies/otus/articles/900452/)​

---

### В каких случаях panic оправдан в продакшен-коде?

Panic в продакшен-коде Go оправдан только в **очень узких случаях**, когда ошибка фатальна и продолжение работы программы бессмысленно или опасно. Это не замена `error`, а экстренный "kill switch".

##### Когда использовать
- **Инициализация критических ресурсов**: не удалось загрузить конфиг, подключиться к БД или открыть обязательный лог-файл в `main()` или `init()`.
	```go
file, err := os.Open("/etc/myapp/config.json")
if err != nil {
    panic("Cannot open config: " + err.Error())
}
	```
Здесь возврат `err` бесполезен — приложение не запустится.
- **Неправильное использование API**: вызывающий код нарушил контракт (nil pointer в публичном методе, неверный invariant). Go stdlib так делает: `sync.Mutex.Lock()` на unlocked mutex.
- **Прерывание в `init()` пакета**: если пакет не может инициализироваться.

##### Когда НЕ использовать
- **Recoverable ошибки**: сетевые сбои, недействительные данные пользователя, I/O ошибки — всегда возвращайте `error`.
- **В HTTP handlers или goroutines**: используйте `recover()` middleware, чтобы один panic не убил весь сервер.[](https://arenda-server.cloud/blog/obrabotka-panic-v-go-luchshie-praktiki/)​
- **Вместо проверки ввода**: `if userID <= 0 { panic("invalid ID") }` — плохой дизайн.

**Правило**: 99% ошибок — `error`. Panic — для 1% случаев, когда "программа сломана навсегда". Rob Pike (создатель Go): "Panic on unexpected, return error on expected".

---

### Как работает recover()? Где именно его нужно вызывать, чтобы он сработал?

`recover()` — это встроенная функция Go, которая перехватывает панику (panic) в текущей горутине и восстанавливает нормальное выполнение. Она возвращает значение, переданное в `panic()`, или `nil`, если паники не было.

##### Где вызывать recover()

`recover()` работает **только внутри отложенных функций** (`defer`). Вызов вне `defer` бесполезен — вернёт `nil` без эффекта.

```go
func safeDivide(a, b int) (result int) {
    // 1. defer выполняется ПОСЛЕ выхода из функции
    defer func() {
        // 2. recover() вызывается ТОЛЬКО внутри defer
        if r := recover(); r != nil {
            // 3. Если была паника — здесь её перехватываем
            fmt.Println("Паника перехвачена:", r)
            result = 0 // устанавливаем значение по умолчанию
        }
    }()
    
    // 4. Этот код может вызвать панику
    result = a / b // panic: division by zero
    return result
}
```

##### Механизм работы
1. `panic()` останавливает выполнение и разматывает стек вызовов
2. Выполняются все `defer`-функции по пути разматывания (LIFO/стек)[](https://habr.com/ru/articles/118898/)​
3. Первый `recover()` в `defer` останавливает разматывание и возвращает контроль
4. Паника "погашается" — горутина продолжает работу[](https://golang-blog.blogspot.com/2020/02/defer-panic-recover-golang.html)​

**Важно:** Один `recover()` на горутину. Если паника в одной горутине — остальные работают нормально.[](https://hacksobesov.com/questions/golang-developer/kak-rabotaet-funkcziya-recover-v-go-i-kakovy-pravila-eyo-ispolzovaniya/)​

---

### Может ли recover() поймать панику в другой горутине?

**Нет, recover() не может поймать панику из другой горутины.**
##### Почему так происходит
`recover()` работает только в той же горутине, где возникла паника. Паника в Go привязана к конкретной горутине — она разворачивает стек вызовов только внутри неё и завершает программу, если доходит до конца горутины без восстановления. Механизм изоляции горутин не позволяет перехватывать паники между ними.

---

### Что такое defer? Опишите порядок выполнения нескольких defer

`defer` в Go — это ключевое слово, которое откладывает выполнение функции до момента возврата из enclosing (окружающей) функции.

Оно идеально подходит для cleanup-операций: закрытия файлов, разблокировки мьютексов, освобождения ресурсов — гарантируя выполнение даже при раннем return или panic.

**Порядок выполнения нескольких `defer`**
Несколько `defer` выполняются в **LIFO порядке (как стек)** (Last In, First Out): последний добавленный вызывается первым.

**Важные нюансы:**
- Аргументы вычисляются **во время объявления `defer`**, а не в момент вызова[](https://arenda-server.cloud/blog/ponimanie-operatora-defer-v-go/)​
- `defer` выполняется **даже при panic** (полезно с `recover()`)[](https://habr.com/ru/companies/otus/articles/833702/)​
- Вложенные функции тоже поддерживают свой стек `defer`

---

### Когда вычисляются аргументы функции, переданной в defer?

Аргументы к функции в `defer` вычисляются **во время объявления `defer`**, а не когда эта функция реально выполняется позже.

Это ключевая особенность Go: сам вызов откладывается до возврата из функции (или паники), но аргументы фиксируются сразу.

Это предотвращает неожиданности с изменяющимися переменными (как в циклах `for i := range` или с замыканиями). Если нужно захватить текущее состояние позже — использовать замыкание.

---

### Как defer влияет на именованные возвращаемые значения (named return values)?

**Пример 1: Модификация именованного возвращаемого значения**
1. Значения присваиваются именованным переменным результата
2. Выполняются все `defer` (в обратном порядке добавления)
3. Функция возвращает финальные значения именованных переменных

```go
func increment() (result int) {
    defer func() {
        result++  // Модифицируем именованное возвращаемое значение
    }()
    
    result = 42
    return        // Возвращает 43, а не 42!
}
```

**Пример 2: Без именованных возвращаемых значений**
Здесь `defer` изменяет локальную `result`, но не влияет на возвращаемое значение.
```go
func incrementNoNamed() int {
    result := 42
    
    defer func() {
        result++ // Модифицирует локальную переменную,
    }()          // НЕ возвращаемое значение
    
    return result  // Возвращает 42
}
```

##### Важные особенности
- `defer` **видит и изменяет** именованные переменные результата[](https://stackoverflow.com/questions/37248898/how-does-defer-and-named-return-value-work/37252098)​
- Работает с несколькими возвращаемыми значениями
- Полезно для логирования, cleanup, коррекции ошибок
- Может привести к неожиданному поведению — используй осознанно

---

### Какова стоимость вызова defer?

Вызов `defer` в Go имеет минимальную стоимость, особенно в современных версиях (Go 1.20+), где оптимизации снизили накладные расходы до уровня обычного вызова функции.

Аргументы `defer`-функции вычисляются сразу при объявлении, а сама функция добавляется в стек отложенных вызовов (LIFO). Выполнение происходит при выходе из функции — это добавляет несколько наносекунд на итерацию в типичных сценариях.

---

### Что будет, если вызвать panic внутри блока defer?

Если вызвать `panic()` внутри блока `defer`, то эта паника **раскрутит стек вызовов вверх** и завершит программу, точно так же, как если бы `panic` был вызван в обычном коде функции.

Блоки `defer` выполняются **после** основного кода функции, но **во время паники** — они **все равно выполняются в порядке LIFO** (стек).

```go
func main() {
    defer fmt.Println("defer 1")  // Выполнится первым (LIFO)
    defer func() {
        panic("panic ВНУТРИ defer!")  // Эта паника прервёт всё
    }()
    defer fmt.Println("defer 2")  // Никогда не выполнится
    
    fmt.Println("Обычный код")
    // panic здесь тоже раскрутит стек и выполнит все defer
}
```

```go
// Обычный код
// defer 1
// panic: panic ВНУТРИ defer!
```
##### Почему так происходит (3 правила defer)
1. **defer** регистрируется **во время нормального выполнения**
2. **defer** выполняются при **return** или **panic** (всегда!)
3. **Паника внутри defer** = новая паника, которая **раскручивает стек дальше**

---

### Что произойдет, если recover() вызван, но паники не было?

Если `recover()` вызван без активной паники, он просто вернёт `nil` и не окажет никакого другого эффекта — программа продолжит выполнение как обычно.

Это стандартное поведение функции: она полезна только внутри `defer` во время паники в той же горутине.

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Поймана паника:", r)
        } else {
            fmt.Println("recover() вернул nil (паники не было)")
        }
    }()
    
    fmt.Println("Обычное выполнение...")
    // recover() здесь сработает, но вернёт nil
}
```

```go
// Обычное выполнение...
// recover() вернул nil (паники не было)
```

##### Ключевые моменты
- `recover()` проверяет наличие паники **только** в текущей горутине
- Без паники: `r == nil`, код продолжается
- С паникой: `r` содержит значение из `panic()`, паника останавливается

---
### Links
[[Base/Interview/Golang/Golang|Golang]]