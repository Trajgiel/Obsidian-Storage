2026-02-17 19:39
Tags: #Interview #golang #panic

- [Почему error — это интерфейс, а не специальный тип данных?](#Почему%20error%20—%20это%20интерфейс,%20а%20не%20специальный%20тип%20данных?)
- [В чем разница между errors.New() и fmt.Errorf()?](#В%20чем%20разница%20между%20errors.New()%20и%20fmt.Errorf()?)
- [Опишите механизм работы errors.Is() и errors.As(). Когда что применять?](#Опишите%20механизм%20работы%20errors.Is()%20и%20errors.As().%20Когда%20что%20применять?)
- [Как реализовать кастомный тип ошибки, который поддерживает Unwrap()?](#Как%20реализовать%20кастомный%20тип%20ошибки,%20который%20поддерживает%20Unwrap()?)
- [Стоит ли возвращать указатель на ошибку (*MyError) или само значение? Почему?](#Стоит%20ли%20возвращать%20указатель%20на%20ошибку%20(*MyError)%20или%20само%20значение?%20Почему?)
- [В какой момент стоит логировать ошибку, а в какой — просто возвращать её выше по стеку?](#В%20какой%20момент%20стоит%20логировать%20ошибку,%20а%20в%20какой%20—%20просто%20возвращать%20её%20выше%20по%20стеку?)
- [Почему проверка if err != nil считается преимуществом языка, а не недостатком?](#Почему%20проверка%20if%20err%20!=%20nil%20считается%20преимуществом%20языка,%20а%20не%20недостатком?)
- [Что происходит с горутиной при возникновении panic?](#Что%20происходит%20с%20горутиной%20при%20возникновении%20panic?)
- [В каких случаях panic оправдан в продакшен-коде?](#В%20каких%20случаях%20panic%20оправдан%20в%20продакшен-коде?)

---

### Почему error — это интерфейс, а не специальный тип данных?

В Go `error` сделан интерфейсом с одним методом `Error() string`, чтобы обеспечить максимальную гибкость и явность в обработке ошибок.
```go
type error interface {
    Error() string
}
```

##### 1. **Гибкость**
Любой тип может реализовать интерфейс `error`, просто добавив метод `Error() string`. Это позволяет создавать кастомные типы ошибок с дополнительной информацией:
```go
type MyError struct {
    Code    int
    Message string
    Time    time.Time
}

func (e *MyError) Error() string {
    return fmt.Sprintf("[%d] %s at %v", e.Code, e.Message, e.Time)
}
```

##### 2. **Простота**

Интерфейс с одним методом — это минималистичный подход, характерный для Go. Он легко понимается и реализуется.

Go предпочитает композицию наследованию. Интерфейсы позволяют разным типам ошибок "быть ошибками" без необходимости наследования от базового класса.
##### 3. **Обёртывание ошибок (wrapping)**

Поскольку это интерфейс, легко создавать обёртки для ошибок, добавляя контекст:
```go
type wrappedError struct {
    err   error
    msg   string
}

func (w *wrappedError) Error() string {
    return w.msg + ": " + w.err.Error()
}
```

---

### В чем разница между errors.New() и fmt.Errorf()?

`errors.New()` и `fmt.Errorf()` — это два основных способа создания ошибок в Go, но они различаются по функциональности и производительности.

##### 1. **errors.New()** (из пакета `errors`)
```go
func New(text string) error
```
- Принимает только **строку** и создает ошибку с этим сообщением
- Простой и быстрый способ создать ошибку
- Не поддерживает форматирование
- Быстрее (~0.17 нс) и не выделяет лишнюю память.[](https://www.linkedin.com/pulse/optimize-your-go-code-use-errorsnew-instead-fmterrorf-engin-a%C3%A7%C4%B1kg%C3%B6z-j28hf)​
```go
err := errors.New("пользователь не найден")
err := errors.New("ошибка подключения к базе данных")
```

##### 2. **fmt.Errorf()** (из пакета `fmt`)
```go
func Errorf(format string, a ...any) error
```
- Поддерживает **форматирование строки** (как `fmt.Sprintf`)
- Позволяет вставлять переменные в сообщение об ошибке (контекст)
- С **Go 1.13+** поддерживает **обертывание ошибок** через `%w` (wrapping)
- Медленнее (~68 нс) из-за форматирования
```go
// С форматированием
err := fmt.Errorf("пользователь с ID %d не найден", userID)
err := fmt.Errorf("ошибка: %s, код: %d", message, code)

// С обертыванием ошибки (Go 1.13+)
originalErr := someFunction()
err := fmt.Errorf("не удалось обработать данные: %w", originalErr)
```

В современном Go чаще используется `fmt.Errorf()` из-за его гибкости!

---

### Опишите механизм работы errors.Is() и errors.As(). Когда что применять?
`errors.Is()` и `errors.As()` — это функции из пакета `errors`, которые работают с цепочками ошибок, созданными через `%w` в `fmt.Errorf` (ошибками, которые оборачивают другие ошибки).
Они проходят по дереву ошибок (через `Unwrap()`) и позволяют проверять совпадения без прямого `==` или `type assertion`.

##### 1. `errors.Is(err, target error)`
Рекурсивно проверяет, **является ли ошибка** (или любая в её цепочке) **конкретным значением**.
```go
   err := io.EOF
    
    if errors.Is(err, io.EOF) {
        fmt.Println("Достигнут конец файла")
    }
```
**Когда применять:** Когда нужно проверить **значение** ошибки.

##### 2. `errors.As(err interface{}, target interface{})`
Рекурсивно проверяет **тип ошибки** в цепочке и **извлекает** её в указатель для доступа к полям.
```go
var pathErr *PathError
    err := &PathError{Path: "/tmp/file.txt", Err: errors.New("permission denied")}
    
    if errors.As(err, &pathErr) {
        fmt.Printf("Ошибка пути: %s\n", pathErr.Path)
        // Теперь можно использовать поля и методы PathError
    }
```
**Когда применять:** Когда нужна **структурированная информация** из ошибки.

##### Резюме

- **`errors.Is()`** — для проверки: «Является ли ошибка (или какая-то в цепочке) этой конкретной ошибкой?»
- **`errors.As()`** — для извлечения: «Есть ли в цепочке ошибка такого типа, и если да — дай мне к ней доступ»

Обе функции работают с **цепочками ошибок**, поэтому их нужно использовать вместо прямого сравнения `err == io.EOF` или приведения типов, когда ошибки оборачиваются через `fmt.Errorf("%w", err)` или метод `Unwrap()`.

---

### Как реализовать кастомный тип ошибки, который поддерживает Unwrap()?

Чтобы реализовать кастомный тип ошибки в Go с поддержкой `Unwrap()`, нужно создать структуру, которая реализует интерфейс `error` (метод `Error()`) и дополнительно метод `Unwrap() error`. Это позволит использовать `errors.Is()`, `errors.As()` и `errors.Unwrap()` из пакета `errors` (Go 1.13+).

```go
import (
    "errors"
    "fmt"
)

type CustomError struct {
    msg string
    err error // вложенная ошибка
}

// Обязательный метод для интерфейса error
func (e *CustomError) Error() string {
    if e.err != nil {
        return fmt.Sprintf("%s: %v", e.msg, e.err)
    }
    return e.msg
}

// Метод для поддержки unwrap (Go 1.13+)
func (e *CustomError) Unwrap() error {
    return e.err
}

func someOperation() error {
    baseErr := errors.New("базовая ошибка")
    return &CustomError{
        msg: "кастомная обертка",
        err: baseErr,
    }
}

func main() {
    err := someOperation()
    fmt.Println(err) // "кастомная обертка: базовая ошибка"
    
    // Проверяем тип через цепочку ошибок
    var target *CustomError
    if errors.As(err, &target) {
        fmt.Println("Это CustomError:", target.msg)
    }
    
    // Проверяем конкретную ошибку в цепочке
    if errors.Is(err, errors.New("базовая ошибка")) {
        fmt.Println("Найдена базовая ошибка")
    }
    
    // Извлекаем вложенную ошибку
    unwrapped := errors.Unwrap(err)
    fmt.Println("Unwrapped:", unwrapped)
}
```

##### Альтернатива с fmt.Errorf (%w)

Если не нужен кастомный тип, используй стандартный способ:
```go
err := fmt.Errorf("кастомное сообщение: %w", errors.New("базовая ошибка"))
if errors.Is(err, errors.New("базовая ошибка")) {
    // сработает
}
```
Этот подход проще, но кастомный тип дает больше контроля (дополнительные поля, методы).

---

### Стоит ли возвращать указатель на ошибку (*MyError) или само значение? Почему?
В Go стандартная практика — возвращать **значение ошибки** (`error`), а не указатель на неё (`*MyError`). Это значение обычно либо `nil` (успех), либо конкретный объект, реализующий интерфейс `error`.

Стандартная библиотека Go всегда возвращает значения `error` — посмотрите на `errors.New()`, `fmt.Errorf()`, `io.EOF`. Указатели не используются, потому что:
- Интерфейс `error` содержит метод `Error() string`, который работает одинаково для значений и указателей.
- Значения ошибок **маленькие и копируются дёшево** (обычно это строка или небольшая структура).
- Нет необходимости в мутабельности — ошибки иммутабельны по дизайну.

Всегда возвращайте `error`, а не `*error`. Это идиоматичный код, который легко читать и поддерживать.

---

### В какой момент стоит логировать ошибку, а в какой — просто возвращать её выше по стеку?

В Go принято **возвращать ошибку вверх по стеку** в большинстве случаев, а **логировать только на границе системы** (handler, middleware, main), где ошибка преобразуется в ответ пользователю или завершение программы.

##### Когда **НЕ** стоит логировать ошибку (просто возвращаем):
1. **Внутри пакета / на уровне бизнес-логики**
    - Если вы находитесь в середине цепочки вызовов
    - Когда ошибка — это ожидаемый результат, который вызывающий код может обработать
    - Если вы не обладаете контекстом для принятия решения
2. **Когда вызывающий код может восстановиться**
    - Например, попробовать альтернативный путь, повторить запрос и т.д.

##### Когда **стоит** логировать ошибку:
1. **На границе слоёв / на верхнем уровне**
    - В `main()`, HTTP-хендлерах, фоновых воркерах
    - Когда ошибка достигает точки, где она больше не может быть обработана
2. **Когда ошибка не может быть восстановлена**
    - Критические ошибки, которые требуют внимания
3. **Когда вы добавляете контекст и "съедаете" ошибку**
    - Если вы не возвращаете ошибку выше, а обрабатываете её на месте

##### Золотое правило:
> **Логируйте ошибку там, где она впервые становится необрабатываемой (или там, где вы принимаете решение её "съесть").**

##### Полезная практика: обёртывание ошибок

Используйте `fmt.Errorf("...: %w", err)` для добавления контекста, но не логируйте на каждом уровне.
Таким образом, логирование происходит **один раз** — на верхнем уровне, а стек ошибки сохраняется через `errors.Is`, `errors.As`, или `%+v` с `pkg/errors`.

---

### Почему проверка if err != nil считается преимуществом языка, а не недостатком?
Проверка `if err != nil` в Go считается преимуществом, потому что она делает обработку ошибок **явной, предсказуемой и компилируемой**.

##### Явная сигнатура функций
Вместо скрытых исключений (как в Java/C++) каждая функция четко объявляет, что может вернуть ошибку.
```go
func readFile(path string) ([]byte, error)  // Ошибка в сигнатуре!
```
Компилятор заставит обработать `error` — забудешь проверку, код не соберется.

##### Типобезопасность и контроль потока
```go
f, err := os.Open("file.txt")
if err != nil {
    return err  // Ранний выход, логика дальше не выполняется
}
defer f.Close()  // Гарантированное закрытие
```
- Нет "магии" исключений — видишь все пути выполнения
- Легко добавить контекст: `fmt.Errorf("read %s: %w", path, err)`
- Можно вернуть несколько значений: `found bool, err error`

##### Обработка наверху (не внизу)
```go
func processUser(id int) error {
    user, err := db.GetUser(id)
    if err != nil { return err }
    
    orders, err := db.GetOrders(user.ID)
    if err != nil { return err }
    
    // main() или middleware решает, что делать с ошибкой
    return sendReport(user, orders)
}
```
В `main()` или HTTP handler'е:
```go
if err := processUser(123); err != nil {
    log.Printf("failed: %v", err)  // Логируем с контекстом
    http.Error(w, "bad request", 400)
    return
}
```


Это заставляет писать надежный код — сначала бесит, потом ценишь предсказуемость!

---

### Что происходит с горутиной при возникновении panic?

##### Последствия для горутины
- Go начинает **unwinding стека** (раскрутку стека вызовов) именно в этой горутине.
- Выполняются все **defer-функции** в обратном порядке (LIFO) до момента panic.
- Если в этих defer вызывается `recover()`, паника **поймана** — горутина продолжает работу.

##### Последствия для программы
- **Panic изолирован** — не распространяется на другие горутины и main.[](https://habr.com/ru/companies/otus/articles/900452/)​
- Если recover не вызван, после unwinding **вся программа крашится** с выводом stack trace **только проблемной горутины**.
- Остальные горутины **продолжают работать** до своего завершения или другой паники.

##### Безопасный запуск горутин
```go
func safeGo(fn func()) {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Panic пойман: %v\n%s", r, debug.Stack())
            }
        }()
        fn()
    }()
}
```
**Всегда** используй такую обёртку для production![](https://habr.com/ru/companies/otus/articles/900452/)​

---

### В каких случаях panic оправдан в продакшен-коде?

Panic в продакшен-коде Go оправдан только в **очень узких случаях**, когда ошибка фатальна и продолжение работы программы бессмысленно или опасно. Это не замена `error`, а экстренный "kill switch".

##### Когда использовать
- **Инициализация критических ресурсов**: не удалось загрузить конфиг, подключиться к БД или открыть обязательный лог-файл в `main()` или `init()`.
	```go
file, err := os.Open("/etc/myapp/config.json")
if err != nil {
    panic("Cannot open config: " + err.Error())
}
	```
Здесь возврат `err` бесполезен — приложение не запустится.
- **Неправильное использование API**: вызывающий код нарушил контракт (nil pointer в публичном методе, неверный invariant). Go stdlib так делает: `sync.Mutex.Lock()` на unlocked mutex.
- **Прерывание в `init()` пакета**: если пакет не может инициализироваться.

##### Когда НЕ использовать
- **Recoverable ошибки**: сетевые сбои, недействительные данные пользователя, I/O ошибки — всегда возвращайте `error`.
- **В HTTP handlers или goroutines**: используйте `recover()` middleware, чтобы один panic не убил весь сервер.[](https://arenda-server.cloud/blog/obrabotka-panic-v-go-luchshie-praktiki/)​
- **Вместо проверки ввода**: `if userID <= 0 { panic("invalid ID") }` — плохой дизайн.

**Правило**: 99% ошибок — `error`. Panic — для 1% случаев, когда "программа сломана навсегда". Rob Pike (создатель Go): "Panic on unexpected, return error on expected".

---
### Links
[[Base/Interview/Golang/Golang|Golang]]