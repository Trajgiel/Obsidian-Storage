2026-02-04 23:04
Tags: #Interview #golang #arrays #slices

- [Что такое slice?](#Что%20такое%20slice?)
- [Чем массив отличается от слайса? Чем хорош массив по сравнению со слайсом?](#Чем%20массив%20отличается%20от%20слайса?%20Чем%20хорош%20массив%20по%20сравнению%20со%20слайсом?)
- [Как работает append?](#Как%20работает%20append?)
- [Какие методы оптимизации работы со слайсами ты применял в работе?](#Какие%20методы%20оптимизации%20работы%20со%20слайсами%20ты%20применял%20в%20работе?)
- [С какой скоростью идет поиск в массиве и почему?](#С%20какой%20скоростью%20идет%20поиск%20в%20массиве%20и%20почему?)

---

### Что такое slice?

Это динамический, изменяемая структура данных в виде последовательности элементов одного типа, представляющий собой удобную и гибкую обертку над обычным массивом.

---

### Чем массив отличается от слайса? Чем хорош массив по сравнению со слайсом?

| Массив                                                                                                               | Слайс                                                                                                                   |
| -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Имеет фиксированную длину, которая задается при его создании.<br>Его размер не может изменяться после инициализации. | Более гибкий и удобный для работы, поскольку его размер можно изменять динамически.                                     |
| Массивы более эффективны по памяти и производительности для фиксированных размеров.                                  | Слайсы являются более высокоуровневыми абстракциями по сравнению с массивами и поддерживают множество полезных функций. |

---

### Как работает append?

append в Go используется для добавления новых элементов к срезу.
Она принимает в качестве первого аргумента исходный срез, а затем одно или несколько значений, которые нужно добавить.
- Если у исходного среза хватает вместимости (capacity), элементы просто добавляются в существующий массив, и длина среза увеличивается.
- Если вместимости недостаточно, append создаёт новый массив большего размера (x2, если cop > 256 то 1/4), копирует туда данные старого среза вместе с новыми элементами, и возвращает новый срез, который ссылается на этот массив.

Важно помнить, что append возвращает новый срез и не мутирует старый, и обычно результат нужно присваивать обратно переменной среза, иначе добавленные элементы будут потеряны.

---

### Какие методы оптимизации работы со слайсами ты применял в работе?

- Предварительное выделение памяти: Использование make с предварительно заданной ёмкостью для минимизации количества операций выделения памяти и копирования при увеличении слайса.
- Минимизация операций append: Использование функции append эффективно, когда вы заранее знаете приблизительный размер конечного слайса.
- Использование слайсов с фиксированной длиной: В некоторых случаях можно использовать слайсы с заранее известной длиной, чтобы избежать необходимости увеличения размера.
- Использовать copy для создания копий слайсов, когда нужно избежать изменения базового массива.

---

### Какая есть функции для создания слайса с длиной отличной от нуля?

В Go для создания слайса с длиной, отличной от нуля, используется встроенная функция make. Она позволяет задать как длину, так и емкость слайса
```go
mySlice := make([]тип, длина, емкость)

mySlice := make([]int, 5, 10)
```

Также слайс можно создавать через инициализацию литералами
```go
mySlice := []int{1, 2, 3}
```

---

### С какой скоростью идет поиск в массиве и почему?

Поиск в массиве (срезе) в Golang обычно происходит за линейное время *O(n)*, где *n* - количество элементов. Это связано с тем, что для нахождения определенного элемента в **неотсортированном** массиве приходится последовательно сравнивать каждый элемент, пока не будет найден нужный или не закончится массив.

Если массив **отсортирован**, то можно использовать бинарный поиск, который работает за *O(log ⁡n)*. В Go есть встроенные функции для бинарного поиска в отсортированных срезах в пакете sort.

---
### Links
[[Base/Interview/Golang/Golang|Golang]]