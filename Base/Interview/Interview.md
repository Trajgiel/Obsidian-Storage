2025-04-12 23:03
Tags: #Interview

- [Самопрезентация](#Самопрезентация)
- [[Base/Interview/CSS|CSS]]
- [[Base/Interview/HTML|HTML]]
- [[Programming Paradigms]]
- [[Base/Interview/JavaScript|JavaScript]]
- [[Base/Interview/TypeScript|TypeScript]]
- [[Base/Interview/React|React]]
- [[Base/Interview/Node.js|Node.js]]
- [[Kata(ы)]]

---

### Самопрезентация

Меня зовут Владимир, и я JavaScript разработчик с более чем 5 годами опыта.
За это время я успел поработать над множеством интересных проектов, от корпоративных приложений до веб-игр.

Я специализируюсь на создании современных веб-приложений, мой опыт включает работу как с фронтендом, так и с бэкендом.

На фронтенде я специализируюсь на JavaScript и TypeScript, а также работаю с React.js и Next.js.
Для стилизации использую CSS-фреймворки, такие как TailwindCSS, Material UI и Styled Components.
Также я знаком с инструментами сборки, такими как Webpack и Vite.

На бэкенде я работаю с Node.js и его фреймворками, такими как Express и Nest.js. Имею опыт работы с базами данных, включая реляционные (PostgreSQL) и нереляционные (MongoDB).

Участвовал в разработке платформы для веб-игр, занимался проектированием и созданием микрофронтенд-архитектуры, и созданием веб-игр.

Был опты реализацией системы авторизации и аутентификации на базе OAuth 2.0.

Участвовал в рефакторинге крупного проекта, переводя кодовую базу с классового React и JavaScript на функциональный React и TypeScript.

Создовал мобильное приложение с помошью React ionic, бекенд чать которого взаимодействовала с API ChatGPT.

Один из моих последних проектов — это внутреннее приложение для анализа продуктивности продуктовых команд, основанное на данных из Jira. Я разработал интерфейс с большим количеством динамических таблиц и графиков, используя React и Chart.js. Для бэкенда использовал Node.js, а данные хранились в PostgreSQL. Благодаря этому приложению менеджеры смогли сократить время на анализ данных на 30% и повысить точность планирования.

Я постоянно развиваюсь, изучая новые технологии и подходы к разработке. Мне нравится работать в команде, где каждый участник ценен, и я всегда готов делиться своими знаниями и опытом для достижения общего успеха.

Буду рад с вами пообщаться и ответить на ваши вопросы.

---

Один из моих последних проектов — это внутреннее приложение для анализа продуктивности продуктовых команд, основанное на данных из Jira. Я разработал интерфейс с большим количеством динамических таблиц и графиков, используя React и Chart.js. Для бэкенда использовал Node.js, а данные хранились в PostgreSQL. Благодаря этому приложению менеджеры смогли сократить время на анализ данных на 30% и повысить точность планирования.

В другом проекте я занимался реализацией системы авторизации и аутентификации на базе **OAuth 2.0** . Это было необходимо для обеспечения безопасного доступа к API нашего бэкенд-приложения. Я внедрил механизм выдачи и обновления токенов (access token и refresh token), внедрил стратегию ролей для управления правами пользователей. В результате система стала более безопасной и масштабируемой, а также позволила подключать сторонние сервисы через OAuth-провайдер.

Также я участвовал в разработке платформы для веб-игр на Next.js с использованием микрофронтенд-архитектуры. Каждая игра была реализована как отдельный модуль на React, что позволило легко добавлять новые игры без пересечения с основным приложением. Для обеспечения высокой отзывчивости использовал WebSocket. Также мы успешно настроили SEO-оптимизацию, что помогло повысить видимость платформы в поисковых системах.

В своей работе я часто сталкиваюсь с легаси-кодом. Например, я участвовал в рефакторинге крупного проекта, переводя кодовую базу с классового React и JavaScript на функциональный React и TypeScript. Это позволило улучшить читаемость кода, снизить количество ошибок и ускорить разработку новых функций на 20%.

---

В одном из проектов я работал над внутренним инструментом, который отображал данные из Jira - довольно объёмные таблицы с задачами, их статусами, исполнителями, сроками и прочими полями. Сначала приложение работало медленно при большом количестве записей, особенно при рендере таблиц и загрузке SVG-иконок. Я решил провести комплексную оптимизацию.

Первой проблемой было то, что таблица с сотнями строк начинала лагать при скролле. Я внедрил **виртуализацию** с помощью библиотеки `react-virtual`. Это позволило отрисовывать только те строки, которые видны пользователю в текущий момент. Так мы значительно снизили количество DOM-элементов и нагрузку на движок JS.

Данные из Jira были довольно объёмными, и повторные запросы сильно нагружали API. Я начал использовать **RTK Query** , часть Redux Toolkit. Это дало нам мощный механизм кэширования, автоматическую обработку состояний загрузки и ошибок, а также возможность переиспользования данных между компонентами без лишних запросов.  
Также я настроил **keepUnusedDataFor** , чтобы освобождать память от неиспользуемых данных через определённое время, чтобы не держать всё в памяти бесконечно.

Иконок было много, и изначально они подключались как отдельные файлы через `import`, что вызывало множество HTTP-запросов и увеличивало время загрузки. Я объединил все SVG в один спрайт с помощью Webpack-плагина (например, `svg-sprite-loader`), и после этого иконки стали загружаться одним файлом, что ускорило первый рендер и снизило нагрузку на сеть.

Для страниц, где контент был большим, но не всегда нужен сразу, я использовал **ленивую загрузку** с помощью `React.lazy()` и `Suspense`. Например, детальная информация по задаче или графики отображались только при клике пользователя. Это помогло уменьшить начальный размер бандла и ускорить первую загрузку.

Чтобы понять, какие именно части приложения тормозят, я активно использовал **вкладку Performance в Chrome DevTools** . Записав профиль выполнения, я увидел, что:

- Большое количество времени тратилось на рендеринг таблиц.
- Были частые перерисовки компонентов, которых можно было избежать.
- Некоторые эффекты и функции выполнялись чаще, чем нужно.

На основе этих данных я смог точно определить узкие места и применить конкретные оптимизации: `React.memo`, `useCallback`, `useMemo`, и, конечно же, виртуализацию.

В результате всех этих изменений:
- Время первой загрузки сократилось почти вдвое.
- Плавность прокрутки таблиц стала идеальной.
- Уменьшилось количество сетевых запросов.
- Общая отзывчивость интерфейса заметно улучшилась.

---
---
##### 1) **Замыкание - что такое и для чего?**
Это механизм языка, который позволяет функции сохранять ссылку на лексическое окружение, в котором эта функция была создана.

для чего: Инкапсуляция, мемоизация, работа с колбэками.

##### 2) **Прототип и наследование?**
-  Реализация ООП в JS.
- Повторное использование кода.
- Уменьшение потребления памяти (методы хранятся один раз в прототипе).

##### 3)  **Как с помощью Java скрипта получить доступ DOM**
```js
document.getElementById('id');              // один элемент
document.getElementsByClassName('class');   // HTMLCollection
document.getElementsByTagName('div');       // HTMLCollection
document.querySelector('.class #id');       // первый подходящий элемент
document.querySelectorAll('div');           // NodeList
```

##### 4) **Для селекторов какие функции, и сколько элементов вернет?**
```js
document.querySelector('.class #id');       // первый подходящий элемент
document.querySelectorAll('div');           // NodeList
```

##### 5) **Как можем добавить и удалить JS?**
```js
const script = document.createElement('script'); // создаём <script>
script.src = 'myScript.js'; // указываем путь к файлу.
script.async = true; // !необязательно! или defer, в зависимости от задачи
document.head.appendChild(script); // добавляем в DOM.
...
script.remove(); // Потом удаляем:
```

Возможно понадобиться:
- Lazy loading - Подгрузка скриптов только при необходимости
- Виджеты сторонних сервисов - Google Analytics, Yandex.Metrica, чаты и т.д.
- тестирование - Загрузка разных версий кода в зависимости от условий
- В dev-средах для обновления модулей без перезагрузки

##### 6) **Какие задачи в JS для асинхронности?**
- Promise
- Таймеры
- async/await
- Web Workers (вне основного потока)
- Event Loop
- Анимации (через requestAnimationFrame)

##### 7) **Что такое CORS политика и для чего нужна?**
CORS - механизм безопасности браузера, который ограничивает запросы между разными доменами (origin).

Зачем нужна:
- Защита от CSRF, XSS и других атак.
- Контроль, какие сайты могут запрашивать ресурсы с сервера.

**XSS** - Атака, при которой злоумышленник внедряет **вредоносный JavaScript-код** на сайт, который затем выполняется у других пользователей.

Защита:
- Экранировать все данные перед выводом.
- Использовать фреймворки (React автоматически экранирует JSX).
- Устанавливать заголовок `Content-Security-Policy` (CSP).

**CSRF** - Атака, при которой злоумышленник заставляет пользователя выполнить нежелательное действие на сайте, где он уже авторизован.
Защита:
- Проверка заголовка `Origin` / `Referer`.
- Использование **CSRF токенов** (сервер генерирует уникальный токен, который должен быть в форме или заголовке).

##### 8) **Как бэкэнд дает фронтэнду понять...**
**Он добавляет специальные HTTP-заголовки в ответ:**
```http
Access-Control-Allow-Origin: https://your-frontend.com 
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorizatio
```

**Если вопрос про передачу данных:**
  JSON (чаще всего)
  XML (редко)
  GraphQL (если используется)

**Статус-кодах HTTP:**
`100` - Информационные
`200` - Успех
`300` - Перенаправления
`400` - Ошибки клиента
`500` - Ошибки сервера

**Вариант: Заголовки, куки, метаданные**
`Content-Type`: тип данных (`application/json`, `text/html`)
`Authorization`: токен для авторизации
`Cache-Control`: инструкции по кэшированию
`X-Rate-Limit`: ограничения на количество запросов

##### 9) **HTML: Базовые элементы**
Это основные теги, из которых строится структура веб-страницы:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="utf-8" />
    <title>Заголовок страницы</title>
    ...
  </head>
  <body>
    <h1>Заголовок</h1>
	...
  </body>

  <script type="module" src="/src/index.tsx"></script>
</html>
```

##### 10) **Семантические теги, для чего нужны, примеры?**
Семантические теги описывают смысл содержимого, а не только его вид.
-SEO оптимизация
-Доступность (screen readers)
-Читаемость кода

##### 11) **Что такое псевдо классы и псевдоэлементы?**

Псевдоклассы (`:hover`, `:nth-child`, `:first-child`, `:visited`, `:focus`) - описывают состояние элемента.

Псевдоэлементы (`::before`, `::after`, `::placeholder`, `::first-line`) -
создают виртуальные элементы.

##### 12) **React какие типы компонентов, и в чем разница?**

Class Components — используют классы ES6, имеют state и lifecycle методы.
Functional Components — простые функции, до React 16.8 не имели состояния.

##### 13) **Компонент высшего порядка что такое и для чего?**
HOC - это функция, которая принимает компонент и возвращает новый компонент с дополнительным поведением, логикой.

```tsx
<WithAuth/>
<WithLogger/>
```

##### 14) **Какие основные хуки есть?**

**Hook** - это специальная функция, которая позволяет тебе "подключаться" к состоянию и жизненному циклу

`useState` — управление состоянием
`useFormState` — состояние формы

`useRef` — ссылки на DOM или изменяемые значения
`useImperativeHandle` — доступ к ref из компонента ( forwardRef )

`useEffect` — эффекты (подписки, запросы, DOM-операции)
`useLayoutEffect` — вызывается синхронно после рендера
`useInsertioEffect` — выполняется перед добавлением новых узлов в DOM

`useCallback` / `useMemo` — оптимизация производительности
`useContext` — доступ к контексту

##### 15) **useEffect как с ним работать и для чего?**

```jsx
useEffect(() => {
  // Выполняется после рендера браузера
  return () => {
    // Очистка после демонтирования компонента
  };
}, [зависимости]);
```

##### 16) **Что такое Redux и для чего он нужен?**
Инструмент для хранения состояния в приложений.
`State` — единое дерево состояний
`Actions` — описание события
`Reducers` — функции, изменяющие состояние
`Store` — хранит состояние, применяет редьюсеры, отправляет экшены

##### 17) **Какие библиотеки использует кандидат и почему?**

- **redux / mobX** — работа с состоянием
- **RTK Query** — для работы с данными если необходимо
- **axios** — HTTP-запросы
- **Tailwind CSS / Material UI** — стилизация
- **formik / react-hook-form** — работа с формами
- **react-router-dom** — маршрутизация
- **zod / yup** — валидация

##### 18) **Как можно оптимизировать приложение, таблицы ?**
Из моего опыта:
- Virtualization - рендер только видимых строк `react-virtual`
- Lazy loading -загрузка именно нужного контента
- RTK Query - кэширование данных
- SVG в один спрайт - использование одного svg
- `<picture><source>...<>` - картинки разных вариантов

##### 19) **Адаптивная верстка для чего нужна?**
Чтобы сайт корректно отображался на устройствах с разным размером экрана.
- Media queries
- Flexbox/Grid
- Mobile-first подход

```css
@media (max-width: 768px) {
  .menu {
    flex-direction: column;
  }
}
```
##### 20) **Какие есть методы, нативная?**

- `Array.prototype.map`, `filter`, `reduce`, `forEach`, `find`, `some()`, `every()`
- `Object.keys`, `values`, `entries`
- `Function.call`, `apply`, `bind`
- `JSON.stringify(obj)`,  `.parse(str)`
---
### Links
