2025-02-24 21:42
Tags: #GarbageCollector

Сборщик мусора (Garbage Collector) в JavaScript — это автоматический механизм, который отслеживает и освобождает память, которую больше не используют объекты или переменные. Это позволяет разработчикам не беспокоиться о ручном управлении памятью.

### Как работает сборщик мусора?

Основная задача сборщика мусора — найти и удалить объекты, на которые больше нет ссылок в коде. Процесс работы сборщика мусора можно разделить на несколько ключевых концепций:

---
### 1. **Учет ссылок (Reference Counting)**

Один из простых способов работы сборщика мусора — подсчет ссылок на объекты. Если число ссылок на объект становится равным нулю, значит, этот объект больше недоступен для программы, и его можно безопасно удалить.

```js
let obj = { name: "John" }; // Создаем объект и создаем ссылку на него
obj = null; // Удаляем ссылку на объект
```

После того как `obj` становится `null`, объект `{ name: "John" }` больше недоступен, и сборщик мусора может его удалить.

---

### 2. **Маркировка и очистка (Mark-and-Sweep Algorithm)**

Это более современный и надежный алгоритм, который используется в JavaScript. Он работает следующим образом:

#### Шаг 1: Маркировка корневых объектов

JavaScript начинает процесс с корневых объектов (root objects), таких как глобальные переменные или локальные переменные функций, которые находятся в стеке выполнения. Эти объекты всегда считаются доступными.

#### Шаг 2: Поиск достижимых объектов

От корневых объектов сборщик мусора рекурсивно переходит к всем объектам, на которые они ссылаются, и маркирует их как "достижимые". Этот процесс повторяется до тех пор, пока не будут обработаны все связанные объекты.

#### Шаг 3: Очистка недостижимых объектов

Все объекты, которые не были маркированы как достижимые, считаются мусором и удаляются из памяти.

```js
function createObjects() {
    let obj1 = { name: "Alice" }; // Локальная переменная
    let obj2 = { name: "Bob" };   // Локальная переменная
    obj1.friend = obj2;          // obj1 ссылается на obj2
    obj2.friend = obj1;          // obj2 ссылается на obj1
} // Когда функция завершается, obj1 и obj2 становятся недостижимыми
```

---

### **Циклические ссылки**

Алгоритм "маркировка и очистка" успешно справляется с циклическими ссылками, потому что он определяет, действительно ли объекты достижимы из корневых объектов.

```js
let objA = {};
let objB = {};
objA.ref = objB; // objA ссылается на objB
objB.ref = objA; // objB ссылается на objA

objA = null; // Удаляем ссылку на objA
objB = null; // Удаляем ссылку на objB
```

После того как `objA` и `objB` становятся `null`, они больше не достижимы из корневых объектов, и сборщик мусора удалит их, даже несмотря на то, что они ссылались друг на друга.

---

### **Утечки памяти**

Утечка памяти происходит, когда объекты остаются в памяти, даже если они больше не нужны. Вот несколько распространенных причин утечек памяти:

- Забытые таймеры или интервалы (`setInterval`, `setTimeout`).
- События, на которые забыли отписаться (`addEventListener`).
- Циклические ссылки, которые остаются достижимыми.
- Кэширование объектов без механизма очистки.

---

Сборщик мусора в JavaScript автоматически управляет памятью, используя алгоритмы типа "маркировка и очистка". Чтобы избежать проблем с памятью, важно:

- Явно удалять ссылки на объекты, когда они больше не нужны.
- Отписываться от событий и очищать таймеры.
- Избегать циклических ссылок, если они не нужны.

Если ты будешь соблюдать эти правила, сборщик мусора будет работать эффективно, и твои приложения будут потреблять меньше памяти.

---
### Links
[[JavaScript]]
