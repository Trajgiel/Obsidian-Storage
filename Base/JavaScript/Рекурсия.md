2022-07-24 19:17
Tags: #рекурсия

Это техника в программировании, при которой функция вызывает саму себя для решения задачи. Каждый рекурсивный вызов работает с меньшей частью исходных данных, пока не достигается **условие выхода из рекурсии**, который завершает рекурсию.

---

```js
function pow(x, n) {
	if (n == 1) return x;  //условия выхода
	else return x * pow(x, n - 1); //следующий шаг
}

pow(2, 3) // 8
```

Когда функция `pow(x, n)` вызывается, исполнение делится на две ветви:
```js
			if n==1 = x
			/
pow(x, n) = 
			\
			else = x * pow(x, n - 1)
```
1.  Если `n == 1`, тогда всё просто. Эта ветвь называется _базой_ рекурсии, потому что сразу же приводит к очевидному результату: `pow(x, 1)` равно `x`.
2.  Мы можем представить `pow(x, n)` в виде: `x * pow(x, n - 1)`. Что в математике записывается как: `xn = x * xn-1`. Эта ветвь – _шаг рекурсии_: мы сводим задачу к более простому действию (умножение на `x`) и более простой аналогичной задаче (`pow` с меньшим `n`). Последующие шаги упрощают задачу всё больше и больше, пока `n` не достигает `1`.

![[rec.png]]
Например, рекурсивный вариант вычисления `pow(2, 4)` состоит из шагов:
1.  `pow(2, 4) = 2 * pow(2, 3)`
2.  `pow(2, 3) = 2 * pow(2, 2)`
3.  `pow(2, 2) = 2 * pow(2, 1)`
4.  `pow(2, 1) = 2`

---

### Когда **не стоит** использовать рекурсию?

- Когда можно обойтись **итерацией** (рекурсия может потреблять больше памяти).
- Когда глубина рекурсии может быть слишком большой и вызвать **переполнение стека**.
- Когда важна **производительность** (рекурсия может быть медленной без оптимизаций).

---
### Links
[[JavaScript]]