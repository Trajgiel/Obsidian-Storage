2025-01-21 16:01
Tags: #nestjs

---

[Nest](https://docs.nestjs.com/) (NestJS) — это фреймворк для создания эффективных и масштабируемых серверных приложений [Node.js](https://nodejs.org/).

### Содержание:
- [Команды](#Команды)
- [Controllers](#Controllers)
- [Services](#Services)
- [Modules](#Modules)
- [Repositories](#Repositories)

**Порядок выполнения:**
1. [Middleware (Промежуточное ПО)](#Middleware)
	- Работает на уровне Express/Fastify.
	- Выполняется **до** всех NestJS-абстракций.
	- Используется для логирования, CORS, обработки тела запроса, аутентификации.
	
2. [Guards (Охранники)](#Guards)
	- Проверяют, можно ли продолжать выполнение запроса.
	- Если `false` — дальше ничего не выполняется.
	
3. [Interceptors (Перехватчики, до контроллера)](#Interceptors)
	- Могут изменять запрос перед его передачей в контроллер.
	- Используются для логирования, кеширования и других операций.
	
4. [Pipes (Конвейеры)](#Pipes)
	 - Валидация и трансформация данных запроса.
	
5. [Controllers (Контроллеры)](#Controllers)
	- Основная обработка запроса, взаимодействие с сервисами.
	
6. [Interceptors (Перехватчики, после контроллера)](#Interceptors)
	- Могут модифицировать ответ перед отправкой клиенту.
	
7. [Exception Filters (Фильтры исключений)](#Exception_Filters)
	- Обрабатывают ошибки, возникшие в контроллере или сервисе.


---

## Команды

| Команда                                        | Описание                                            |
| ---------------------------------------------- | --------------------------------------------------- |
| npm i -g @nestjs/cli<br>                       | Глобально устанавливаем команды nest (если их нету) |
| nest new [project-name]                        | Устанавливаем проект nest.js                        |
| npm i --save class-validator class-transformer | Пакеты валидации и трансформации DTO                |

| Команда                                 | Описание                                      |
| --------------------------------------- | --------------------------------------------- |
| nest g resource [module-name] --no-spec | Создать **полный** шаблон модуля (без тестов) |
| nest g controller [name]                | Создать шаблон контроллера                    |


---

## Controllers
5. Контроллеры
- Основная обработка запроса, взаимодействие с сервисами.

Контроллеры отвечают за обработку входящих **запросов** и отправку **ответов** клиенту.

![[controllers_rest_1.png]]

Назначение контроллера — получать конкретные запросы для приложения. Механизм **маршрутизации** определяет, какой контроллер получает те или иные запросы. Часто у каждого контроллера есть несколько маршрутов, и разные маршруты могут выполнять разные действия.

```ts
import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```


---

## Services

Это классы, которые содержат бизнес-логику приложения.

```ts
import { Injectable } from '@nestjs/common';  
  
@Injectable()  
export class AppService {  
  getHello(): string {  
    return 'Hello World!';  
  }  
}
```

Сервисы обеспечивают разделение логики между контроллерами (которые обрабатывают запросы) и бизнес-слоем приложения, что способствует лучшей организации кода и облегчает тестирование.

---

## Modules

Модуль — это класс, аннотированный декоратором `@Module()`. Декоратор `@Module()`. предоставляет метаданные, которые **Nest** использует для организации структуры приложения.

![[modules_rast_1.png]]

В каждом приложении есть как минимум один модуль, **корневой модуль**. Корневой модуль — это отправная точка, которую Nest использует для построения **графа приложения** — внутренней структуры данных, которую Nest использует для определения взаимосвязей и зависимостей между модулями и поставщиками.

```typescript
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}
```


---

## Repositories

Термин **repository (репозиторий)** относится к паттерну проектирования, который обеспечивает абстракцию над операциями с базой данных. Репозиторий предоставляет интерфейс для взаимодействия с данными, отделяя логику доступа к данным от остальной бизнес-логики приложения.

---

## Middleware
1. Промежуточное ПО
- Работает на уровне Express/Fastify.
- Выполняется **до** всех NestJS-абстракций (до `Guards`, `Interceptors`, `Pipes`).
- Используется для логирования, CORS, обработки тела запроса (`body-parser`), аутентификации.

это функция, которая вызывается **до** обработчика маршрута. Функции middleware имеют доступ к объектам `request` (запроса) и `response` (ответа), а также к `next()` функции middleware в цикле запроса-ответа приложения. **Следующая** функция middleware обычно обозначается переменной с именем `next`.

![[middleware_nest_1.png]]

---

## Guards
2. Охранники
- Проверяют, можно ли продолжать выполнение запроса.
- Если `false` — дальше ничего не выполняется.

У guards **одна задача**. Они определяют, будет ли конкретный запрос обработан обработчиком маршрута или нет, в зависимости от определённых условий (например, разрешений, ролей, списков управления доступом и т. д.), присутствующих во время выполнения. Это часто называют **авторизацией**.

Это класс, аннотированный декоратором `@Injectable()`, который реализует интерфейс `CanActivate`.

![[guards_rest_1.png]]

```ts auth.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}
```

**Aвторизация** — отличный вариант использования Guards, поскольку определённые маршруты должны быть доступны только в том случае, если у вызывающего абонента (обычно это конкретный авторизованный пользователь) есть достаточные разрешения.

Ниже мы настроили guard, привязанного к контроллеру, с помощью декоратора `@UseGuards()`

```ts
@Controller('cats')
@UseGuards(AuthGuard)
export class CatsController {}
```

---

## Interceptors
3. Перехватчики, до контроллера
- Могут изменять запрос перед его передачей в контроллер.
- Используются для логирования, кеширования и других операций.

6. Перехватчики, после контроллера
- Основная обработка запроса, взаимодействие с сервисами.

Interceptors обладают набором полезных функций, основанных на методе [аспектно-ориентированного программирования](https://en.wikipedia.org/wiki/Aspect-oriented_programming) (AOP). Они позволяют:

- привязать дополнительную логику до / после выполнения метода
- преобразовать результат, возвращаемый функцией
- преобразовать исключение, генерируемое функцией
- расширить базовое поведение функции
- полностью переопределить функцию в зависимости от конкретных условий (например, для целей кэширования)

![[interceptors_rest_1.png]]

---
## Pipes
4. Конвейеры (преобразование, проверка)
- Валидация и трансформация данных запроса.

Pipes имеют два типичных варианта использования:
- **преобразование**: преобразуйте входные данные в нужную форму (например, из строки в целое число)
- **проверка**: оцените входные данные и, если они корректны, просто передайте их без изменений; в противном случае вызовите ошибку

Это класс, аннотированный декоратором `@Injectable()`, который реализует интерфейс `PipeTransform`.

![[pipes_rest_1.png]]

Чтобы использовать конвейер, нам нужно привязать экземпляр класса конвейера к соответствующему контексту. В нашем `ParseIntPipe` примере мы хотим связать конвейер с определённым методом обработчика маршрута и убедиться, что он запускается до вызова метода. Мы делаем это с помощью следующей конструкции, которую будем называть привязкой конвейера на уровне параметров метода:

```ts
@Post()
@UsePipes(new ZodValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

```ts
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

Это гарантирует, что выполняется одно из следующих двух условий: либо параметр, который мы получаем в методе `findOne()`, является числом (как и ожидалось при вызове `this.catsService.findOne()`), либо возникает исключение до вызова обработчика маршрута.


---

## Exception_Filters
7. Фильтры исключений
- Обрабатывают ошибки, возникшие в контроллере или сервисе.

В Nest есть встроенный **уровень обработки исключений**, который отвечает за обработку всех необработанных исключений в приложении. Если исключение не обрабатывается кодом вашего приложения, оно перехватывается этим уровнем, который автоматически отправляет соответствующий удобный для пользователя ответ.

![[exception_filters_rest_1.png]]


---
### Links
[[Node.js]]
