2025-11-08 20:01
Tags: #golang 

Слайс - это последовательность элементов одного типа, но в отличие от массива, его длина может изменяться.

Слайс состоит из трёх основных компонентов:
- **Указатель** - ссылается на первый элемент массива, доступный через срез (он может не совпадать с началом самого массива).
- **Длина (length)** - количество элементов в срезе.
- **Емкость (capacity)** - общее количество элементов от начала среза до конца базового массива.

Определить **длину** среза можно с помощью функции `len()`.
Определить **емкость** среза можно с помощью функции `cap()`.

---

Слайс можно создать так же, как массив, но без указания длины, поскольку она изменяемая. При этом можно сразу инициализировать срез, указав его элементы. Рассмотрим разницу между массивом и срезом:
```go
var a []int
var b []int = []int{2, 4, 6}
c := []int{2, 4, 6}
d := []int{2: 10}

fmt.Println(a) // []
fmt.Println(b) // [2 4 6]
fmt.Println(c) // [2 4 6]
fmt.Println(d) // [0 0 10]
```

---

### make

Go также предоставляет удобный способ создания срезов с помощью встроенной функции `make`:

```go
make([]T, length, capacity)
```

При создании среза через `make` в памяти выделяется базовый массив, а срез получает к нему доступ. Его указатель ссылается на первый элемент массива, а длина и емкость определяются в зависимости от переданных параметров.

Для чего может понадобиться явное указание длины и емкости?
- Чтобы инициализировать элементы среза нулевыми значениями (длина).
- Чтобы заранее выделить нужное количество памяти для массива, лежащего в основе среза.
```go
a := make([]int, 5, 10)
fmt.Println(a) // [0 0 0 0 0]
```

---

### Оператор среза

Оператор среза `s[i:j]` создаёт новый срез на основе последовательности `s`, содержащий элементы с индекса `i` по `j-1`. При этом должно выполняться условие: `0 <= i <= j <= cap(s)`. Исходной последовательностью для среза может быть массив, указатель на массив или другой срез. В результате полученный срез содержит `j - i` элементов.

Если `i` не указан, он по умолчанию равен 0. Если `j` не указан, используется длина исходной последовательности `s`.

```go
baseArray := [8]string{"Anna", "Max", "Eva", "Leo", "Nina", "Tom", "Sophie", "Chris"} // базовый массив

slice1 := baseArray[1:5] // со 2-го по 5-й элемент
slice2 := baseArray[:3]  // с 1-го по 3-й элемент
slice3 := baseArray[4:]  // с 5-го до конца

fmt.Println(slice1) // [Max Eva Leo Nina]
fmt.Println(slice2) // [Anna Max Eva]
fmt.Println(slice3) // [Nina Tom Sophie Chris]
```

---

### append()

Функция `append` используется для добавления новых элементов в срез. Её объявление выглядит следующим образом:
```go
func append(slice []Type, elems ...Type) []Type
```

Первый аргумент – это срез, в который добавляются новые элементы. Второй и последующие аргументы – элементы того же типа, что и срез, которые необходимо добавить. `append` возвращает новый срез, включающий исходные элементы и добавленные значения.

```go
numbers := []int{10, 20, 30}
numbers = append(numbers, 40, 50)

fmt.Println(numbers) // [10 20 30 40 50]
```

Использование `append` для удаления элемента из среза:
```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

---

### copy()

```go
func copy(dst, src []Type) int
```

`copy` принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)

fmt.Printf("a = %v\n", a) // a = [1 2 3]
fmt.Printf("b = %v\n", b) // b = [0 0 0]
   
n := copy(b, a)

fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
```

---

### Особенности работы со срезами

```go
func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}
```
В приведенном примере мы создали 2 функции: `fnA` и `fnB`. Первая получает в качестве аргумента массив из 3-х элементов, вторая - срез. Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что `fnB` работала с указателем на массив и изменила непосредственно сам массив, `fnA` же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.

---
### Links
[[Golang]]