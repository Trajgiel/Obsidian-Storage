2025-11-09 19:21
Tags: #golang 

в Go ошибки - это значения с типом `error`, возвращаемые функциями, как и любые другие значения.

```go
var input int

_, err := fmt.Scan(&input) // второй параметр — ошибка

if err != nil {
	fmt.Println("Проверьте типы входных параметров.")
} else {
	fmt.Println(divide(input, 5)) // Выводим результат, если ошибок нет
}
```
Eсли переменная `err` не равна `nil`, то произошла ошибка.
В противном случае - ошибок нет, и программа продолжает выполнение.
Хорошей практикой является возврат ошибки последним возвращаемым значением

---

### Создание ошибок

Стандартная библиотека предоставляет две встроенные функции для создания ошибок: `errors.New` и `fmt.Errorf`. Обе эти функции позволяют нам указывать настраиваемое сообщение об ошибке, которое вы можете отображать вашим пользователям.

```go
import (
    "errors"
    "fmt"
)

func main() {
    err := errors.New("my error")
    fmt.Println("", err)
}
```

---

### Оператор panic()

Оператор **panic** позволяет сгенерировать ошибку и выйти из программы:

```go
package main
import "fmt"

func main() {
    fmt.Println(divide(15, 5)) // Работает нормально
    fmt.Println(divide(4, 0))  // Генерирует ошибку
    fmt.Println("Program has been finished") // Не выполнится
}

func divide(x, y float64) float64 {
    if y == 0 {
        panic("division by zero!") // Генерация ошибки
    }
    return x / y
}
```

После этого выполнение программы будет остановлено, и все последующие операции, такие как вызов `fmt.Println("Program has been finished")`, не будут выполнены.

После вывода сообщения об ошибке будет отображена диагностическая информация о том, где именно возникла ошибка.

---
### Links
[[Golang]]