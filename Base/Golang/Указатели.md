2025-11-10 19:15
Tags: #golang 

**Указатель** - значение, которое указывает на адрес другой переменной.

```go
func main() {
    a := 200
    b := &a         // Referencing
    *b++            // Dereferencing
    fmt.Println(a)
}
```
В этом примере мы инициализируем переменную `а` и ссылающуюся на неё переменную `b`, мы не знаем, где она лежит, однако компилятор об этом позаботится. Оператор `&` (взятие адреса) говорит о том, что в переменную `b` записывается не значение переменной `a`, а её адрес в памяти. Переменная `b` здесь является указателем.

`*` является признаком указателя.

```go
a := 200
var b *int = &a
```

`int` - значит переменная указывает на другую переменную типа **int**

---

### Функция `new`

Можно получить указатель на переменную с помощью встроенной функции `new`.
Эта функция выделяет память для указанного типа и возвращает указатель на него.

```go
func one(xPtr *int) {
    *xPtr = 1
}

func main() {
    xPtr := new(int)  // выделяем память для переменной типа int
    one(xPtr)         // передаем указатель в функцию
    fmt.Println(*xPtr) // выведет: 1
}
```

В отличие от оператора `&`, который возвращает указатель на существующую переменную, `new` создает новую переменную в памяти.

Примечание: в некоторых языках программирования есть различия между использованием `new` и оператора `&`. В этих языках нужно вручную удалять память, выделенную с помощью `new`. Однако Go использует автоматическую сборку мусора, что означает, что память, на которую не осталось ссылок, будет автоматически очищена без необходимости вручную освобождать её. Это делает работу с памятью в Go проще и безопаснее.

---

Также мы можем создать указатель на указатель.

```go
func main() {
   a := 200
   b := &a
   *b++
   c := &b
   **c++ // указатель на указатель
   fmt.Println(a) // 202
}
```

---
### Links
[[Base/Golang/Golang]]